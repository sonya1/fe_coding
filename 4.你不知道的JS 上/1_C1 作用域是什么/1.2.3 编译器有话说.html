<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>1.2.3 编译器有话说</title>
</head>
<body>
	<p>
		为了进一步理解，我们需要多介绍一点编译器的术语。

		编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量a来判断他是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。

		在我们的例子中，引擎会为变量a进行LHS查询。另外一个查询叫做RHS。

		我打赌你一定能猜到L和R的含义，代表左侧和右侧。

		什么东西的左侧和右侧？是一个赋值操作的左侧和右侧。

		换句话说，当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。讲得更准确一点，RHS查询与简单的查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS并不是真正意义上的“赋值操作的右侧”，更准确的说是“非左侧”。

		你可以将RHS理解成retrieve his value(取到它的原值)，这意味着“得到某某的值”。

		让我们继续深入研究。考虑以下代码：console.log(a);其中对a的引用是一个RHS引用，因为这里a并没有赋予任何值。相应的，需要查找并取得a的值，这样才能将值传递给console.log(..).相比之下，例如：a=2；这里对a的引用则是LHS引用，因为实际上我们并不关心当前的值是什么，只是想要为=2这个赋值操作找到一个目标。


		LHS和RHS的含义是“赋值操作的左侧和右侧”并不一定意味着就是“=”赋值操作符的左侧和右侧，赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）以及“谁是赋值操作的源头（RHS）””。

		考虑下面的程序，其中既有LHS和RHS引用：

		<script>
			function foo(a){
				console.log(a); //2
			}

			foo(2);
		</script>
		

		最后一行foo(..)函数的调用需要对foo进行RHS引用，意味着“去找到foo的值，并把他给我”。并且(..)意味着foo的值需要被执行，因此他最好真的是一个函数类型的值！

		这里还有一个容易被忽略却非常重要的细节。

		代码中隐式的a=2操作可能很容易被你忽略掉。这个操作发生在2被当做参数传递给foo(..)函数时，2会被分配给参数a。为了给参数a（隐式的）分配值，需要进行一次LHS查询。

		这里还有对a进行的RHS引用，并且将得到的值传给了console.log(..)。console.log(..)本身也需要一个引用才能执行，因此会对console对象进行RHS查询，并且检查得到的值中是否有一个叫做log的方法。

		最后，在概念上可以理解为在RHS和LHS之间通过对值2进行交互来将其传递进log(..)（通过变量a的RHS查询）。假设log(..)函数的原生视线中它可以接收参数，在将2赋值给其中第一个（也许叫做arg1）参数之前，这个参数需要进行LHS引用查询。
	</p>
</body>
</html>