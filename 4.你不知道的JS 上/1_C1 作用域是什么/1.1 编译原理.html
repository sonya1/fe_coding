<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>1.1 编译原理</title>
</head>
<body>
	尽管通常将JS归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。这个事实对你来说可能显而易见，也可能你闻所未闻，取决于你接触过多少编程语言，具有多少经验。但与传统的编译语言不同，他不是提前编译的，编译结果也不能在分布式系统中移植。

	尽管如此，JS引擎进行编译的步骤和传统的编译语言非常相似，在某些环节可能比预想的要复杂。在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。
	<ul>
		<li>分词/词法分析</li>
		<p>
			这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。例如，考虑程序var a = 2;。这段程序通常会被分解成为下面这些词法单元:var、a、=、2、。空格是否会被当做词法单元，取决于空格在这门语言中是否具有意义。

			分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断a是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。
		</p>
		<li>解析/语法分析</li>
		<p>
			这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（AST）。var a=2;的抽象语法树中可能会有一个叫做VariableDeclaration的顶级节点，接下来是一个叫做Identifier（它的值是a）的子节点，以及一个叫做AssignmenExpression的子节点。AssignmenExpression节点有一个叫做NumericLiteral（它的值是2）的子节点。
		</p>
		<li>代码生成</li>
		<p>
			将AST转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。

			抛开具体细节，简单来说就是有某种方法可以将var a=2;的AST转化为一组机器指令，用来创建一个叫做a的变量（包括分配内存等），并将一个值储存在a中。

			*引擎可以根据需要创建并存储变量。

			比起那些编译过程只有三个步骤的语言的编译器，JS引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。
			因此在这里只进行宏观、简单的介绍，接下来你就会发现我们介绍的这些看起来有点高深的内容与所要讨论的事情有什么关联。

			首先，JS引擎不会有大量的（像其他语言编译器那么多的）时间来进行优化，因为与其他语言不同，JS的编译过程不是发生在构建之前的。

			对于JS来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。在我们所要讨论的作用域背后，JS引擎用尽了各种办法（比如JIT，可以延迟编译甚至实施重编译）来保证性能最佳。

			简单的说，任何JS代码片段在执行前都要进行编译（通常就在执行前）。因此，JS编译器首先会对var a=2;这段程序进行编译，然后做好执行他的准备，并且通常就会马上执行他。
		</p>
	</ul>
</body>
</html>